/**
 * Report Generator
 * 
 * This module provides comprehensive reporting capabilities with multiple format support,
 * customizable templates, flexible filtering, and automated scheduling.
 */

import { 
  EnhancedDisputeRecord,
  EnhancedCreditScore,
  DisputeAnalytics
} from '@/types/enhanced-credit'
import { 
  ComprehensiveProgressReport
} from './progressReports'
import { ProgressReport } from './progressTracker'
import { SuccessRateAnalysis } from './successRateAnalyzer'
import { ScoreImpactAnalysis } from './scoreImpactAnalyzer'

export interface ReportConfiguration {
  reportId: string
  reportType: ReportType
  title: string
  description: string
  template: ReportTemplate
  filters: ReportFilters
  formatting: ReportFormatting
  scheduling?: ReportScheduling
  delivery?: ReportDelivery
}

export enum ReportType {
  PROGRESS_SUMMARY = 'progress_summary',
  SUCCESS_RATE_ANALYSIS = 'success_rate_analysis',
  SCORE_IMPACT_ANALYSIS = 'score_impact_analysis',
  COMPREHENSIVE_ANALYTICS = 'comprehensive_analytics',
  EXECUTIVE_SUMMARY = 'executive_summary',
  DETAILED_DISPUTE_LOG = 'detailed_dispute_log',
  BUREAU_PERFORMANCE = 'bureau_performance',
  ROI_ANALYSIS = 'roi_analysis',
  CUSTOM = 'custom'
}

export interface ReportTemplate {
  templateId: string
  name: string
  description: string
  sections: ReportSection[]
  layout: ReportLayout
  styling: ReportStyling
  customizable: boolean
}

export interface ReportSection {
  sectionId: string
  title: string
  type: SectionType
  content: SectionContent
  order: number
  required: boolean
  customizable: boolean
}

export enum SectionType {
  EXECUTIVE_SUMMARY = 'executive_summary',
  KEY_METRICS = 'key_metrics',
  CHARTS_GRAPHS = 'charts_graphs',
  DATA_TABLE = 'data_table',
  TIMELINE = 'timeline',
  RECOMMENDATIONS = 'recommendations',
  DETAILED_ANALYSIS = 'detailed_analysis',
  APPENDIX = 'appendix',
  CUSTOM_TEXT = 'custom_text'
}

export interface SectionContent {
  data?: any
  chartConfig?: ChartConfiguration
  tableConfig?: TableConfiguration
  textContent?: string
  customContent?: any
}

export interface ChartConfiguration {
  chartType: 'line' | 'bar' | 'pie' | 'scatter' | 'gauge' | 'timeline'
  title: string
  xAxis?: string
  yAxis?: string
  dataSource: string
  colors?: string[]
  showLegend: boolean
  showGrid: boolean
  annotations?: ChartAnnotation[]
}

export interface ChartAnnotation {
  type: 'line' | 'point' | 'text' | 'area'
  value: any
  label: string
  color?: string
}

export interface TableConfiguration {
  columns: TableColumn[]
  sortable: boolean
  filterable: boolean
  paginated: boolean
  pageSize?: number
  showTotals: boolean
  groupBy?: string
}

export interface TableColumn {
  key: string
  title: string
  type: 'text' | 'number' | 'date' | 'currency' | 'percentage'
  width?: string
  sortable: boolean
  filterable: boolean
  format?: string
}

export interface ReportLayout {
  orientation: 'portrait' | 'landscape'
  pageSize: 'letter' | 'a4' | 'legal' | 'tabloid'
  margins: {
    top: number
    right: number
    bottom: number
    left: number
  }
  columns: number
  headerHeight?: number
  footerHeight?: number
}

export interface ReportStyling {
  theme: 'professional' | 'modern' | 'minimal' | 'branded'
  primaryColor: string
  secondaryColor: string
  fontFamily: string
  fontSize: number
  logoUrl?: string
  watermark?: string
}

export interface ReportFilters {
  dateRange: {
    startDate: Date
    endDate: Date
  }
  disputeStatus?: string[]
  bureaus?: string[]
  disputeTypes?: string[]
  creditors?: string[]
  scoreRange?: {
    min: number
    max: number
  }
  customFilters?: { [key: string]: any }
}

export interface ReportFormatting {
  outputFormat: OutputFormat
  compression?: boolean
  password?: string
  watermark?: boolean
  pageNumbers?: boolean
  tableOfContents?: boolean
  appendices?: boolean
}

export enum OutputFormat {
  PDF = 'pdf',
  EXCEL = 'excel',
  CSV = 'csv',
  JSON = 'json',
  HTML = 'html',
  WORD = 'word',
  POWERPOINT = 'powerpoint'
}

export interface ReportScheduling {
  enabled: boolean
  frequency: ScheduleFrequency
  dayOfWeek?: number // 0-6 (Sunday-Saturday)
  dayOfMonth?: number // 1-31
  time: string // HH:MM format
  timezone: string
  nextRun?: Date
  lastRun?: Date
}

export enum ScheduleFrequency {
  DAILY = 'daily',
  WEEKLY = 'weekly',
  MONTHLY = 'monthly',
  QUARTERLY = 'quarterly',
  ANNUALLY = 'annually',
  CUSTOM = 'custom'
}

export interface ReportDelivery {
  method: DeliveryMethod
  recipients: string[]
  subject?: string
  message?: string
  attachmentName?: string
  cloudStorage?: CloudStorageConfig
}

export enum DeliveryMethod {
  EMAIL = 'email',
  DOWNLOAD = 'download',
  CLOUD_STORAGE = 'cloud_storage',
  API_WEBHOOK = 'api_webhook'
}

export interface CloudStorageConfig {
  provider: 'aws_s3' | 'google_drive' | 'dropbox' | 'onedrive'
  bucket?: string
  folder?: string
  credentials?: any
}

export interface GeneratedReport {
  reportId: string
  configuration: ReportConfiguration
  generatedAt: Date
  generatedBy: string
  fileSize: number
  filePath?: string
  downloadUrl?: string
  expiresAt?: Date
  metadata: ReportMetadata
}

export interface ReportMetadata {
  dataPoints: number
  processingTime: number
  version: string
  checksum?: string
  dependencies: string[]
  warnings?: string[]
  errors?: string[]
}

export interface ReportExportOptions {
  format: OutputFormat
  template?: string
  customSections?: ReportSection[]
  filters?: ReportFilters
  styling?: Partial<ReportStyling>
  includeRawData?: boolean
  compression?: boolean
  password?: string
}

export class ReportGenerator {
  private templates: Map<string, ReportTemplate> = new Map()
  private scheduledReports: Map<string, ReportConfiguration> = new Map()

  constructor() {
    this.initializeDefaultTemplates()
  }

  /**
   * Generate a comprehensive report based on configuration
   */
  async generateReport(
    config: ReportConfiguration,
    data: {
      disputes: EnhancedDisputeRecord[]
      creditScores: EnhancedCreditScore[]
      progressReport?: ComprehensiveProgressReport
      successAnalysis?: SuccessRateAnalysis
      scoreImpact?: ScoreImpactAnalysis
    }
  ): Promise<GeneratedReport> {
    const startTime = Date.now()
    
    // Apply filters to data
    const filteredData = this.applyFilters(data, config.filters)
    
    // Generate report content based on template
    const reportContent = await this.generateReportContent(config, filteredData)
    
    // Format and export report
    const exportedReport = await this.exportReport(reportContent, config.formatting)
    
    // Handle delivery if configured
    if (config.delivery) {
      await this.deliverReport(exportedReport, config.delivery)
    }
    
    const processingTime = Date.now() - startTime
    
    return {
      reportId: config.reportId,
      configuration: config,
      generatedAt: new Date(),
      generatedBy: 'system', // Would be actual user in real implementation
      fileSize: exportedReport.size,
      filePath: exportedReport.path,
      downloadUrl: exportedReport.downloadUrl,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      metadata: {
        dataPoints: this.countDataPoints(filteredData),
        processingTime,
        version: '1.0',
        dependencies: ['disputes', 'creditScores'],
        warnings: exportedReport.warnings,
        errors: exportedReport.errors
      }
    }
  }

  /**
   * Export report in multiple formats
   */
  async exportReport(
    content: ReportContent,
    options: ReportExportOptions
  ): Promise<ExportedReport> {
    switch (options.format) {
      case OutputFormat.PDF:
        return await this.exportToPDF(content, options)
      case OutputFormat.EXCEL:
        return await this.exportToExcel(content, options)
      case OutputFormat.CSV:
        return await this.exportToCSV(content, options)
      case OutputFormat.JSON:
        return await this.exportToJSON(content, options)
      case OutputFormat.HTML:
        return await this.exportToHTML(content, options)
      default:
        throw new Error(`Unsupported export format: ${options.format}`)
    }
  }

  /**
   * Schedule automated report generation
   */
  async scheduleReport(config: ReportConfiguration): Promise<string> {
    if (!config.scheduling?.enabled) {
      throw new Error('Report scheduling is not enabled')
    }

    const scheduleId = `schedule_${config.reportId}_${Date.now()}`
    this.scheduledReports.set(scheduleId, config)
    
    // Calculate next run time
    const nextRun = this.calculateNextRunTime(config.scheduling)
    config.scheduling.nextRun = nextRun
    
    // In a real implementation, this would integrate with a job scheduler
    console.log(`Report scheduled: ${scheduleId}, next run: ${nextRun}`)
    
    return scheduleId
  }

  /**
   * Create custom report template
   */
  async createCustomTemplate(
    templateConfig: Partial<ReportTemplate>
  ): Promise<ReportTemplate> {
    const template: ReportTemplate = {
      templateId: `custom_${Date.now()}`,
      name: templateConfig.name || 'Custom Template',
      description: templateConfig.description || 'User-defined custom template',
      sections: templateConfig.sections || [],
      layout: templateConfig.layout || this.getDefaultLayout(),
      styling: templateConfig.styling || this.getDefaultStyling(),
      customizable: true
    }
    
    this.templates.set(template.templateId, template)
    return template
  }

  /**
   * Get available report templates
   */
  getAvailableTemplates(): ReportTemplate[] {
    return Array.from(this.templates.values())
  }

  /**
   * Generate quick export in specified format
   */
  async quickExport(
    data: {
      disputes: EnhancedDisputeRecord[]
      creditScores: EnhancedCreditScore[]
    },
    format: OutputFormat,
    filters?: ReportFilters
  ): Promise<ExportedReport> {
    const filteredData = filters ? this.applyFilters(data, filters) : data
    
    switch (format) {
      case OutputFormat.CSV:
        return await this.exportDisputesToCSV(filteredData.disputes)
      case OutputFormat.JSON:
        return await this.exportToJSON({ data: filteredData }, { format })
      case OutputFormat.EXCEL:
        return await this.exportToExcel({ data: filteredData }, { format })
      default:
        throw new Error(`Quick export not supported for format: ${format}`)
    }
  }

  // Private methods

  private initializeDefaultTemplates(): void {
    // Executive Summary Template
    const executiveSummary: ReportTemplate = {
      templateId: 'executive_summary',
      name: 'Executive Summary',
      description: 'High-level overview with key metrics and insights',
      sections: [
        {
          sectionId: 'summary',
          title: 'Executive Summary',
          type: SectionType.EXECUTIVE_SUMMARY,
          content: {},
          order: 1,
          required: true,
          customizable: false
        },
        {
          sectionId: 'key_metrics',
          title: 'Key Performance Indicators',
          type: SectionType.KEY_METRICS,
          content: {},
          order: 2,
          required: true,
          customizable: true
        },
        {
          sectionId: 'recommendations',
          title: 'Strategic Recommendations',
          type: SectionType.RECOMMENDATIONS,
          content: {},
          order: 3,
          required: true,
          customizable: true
        }
      ],
      layout: this.getDefaultLayout(),
      styling: this.getDefaultStyling(),
      customizable: true
    }

    // Detailed Analytics Template
    const detailedAnalytics: ReportTemplate = {
      templateId: 'detailed_analytics',
      name: 'Detailed Analytics Report',
      description: 'Comprehensive analysis with charts, tables, and detailed insights',
      sections: [
        {
          sectionId: 'overview',
          title: 'Overview',
          type: SectionType.EXECUTIVE_SUMMARY,
          content: {},
          order: 1,
          required: true,
          customizable: false
        },
        {
          sectionId: 'progress_charts',
          title: 'Progress Analysis',
          type: SectionType.CHARTS_GRAPHS,
          content: {
            chartConfig: {
              chartType: 'line',
              title: 'Dispute Progress Over Time',
              xAxis: 'Date',
              yAxis: 'Progress %',
              dataSource: 'progress_data',
              showLegend: true,
              showGrid: true
            }
          },
          order: 2,
          required: true,
          customizable: true
        },
        {
          sectionId: 'success_rates',
          title: 'Success Rate Analysis',
          type: SectionType.CHARTS_GRAPHS,
          content: {
            chartConfig: {
              chartType: 'bar',
              title: 'Success Rates by Bureau',
              xAxis: 'Bureau',
              yAxis: 'Success Rate %',
              dataSource: 'bureau_success_data',
              showLegend: false,
              showGrid: true
            }
          },
          order: 3,
          required: true,
          customizable: true
        },
        {
          sectionId: 'dispute_details',
          title: 'Dispute Details',
          type: SectionType.DATA_TABLE,
          content: {
            tableConfig: {
              columns: [
                { key: 'id', title: 'Dispute ID', type: 'text', sortable: true, filterable: true },
                { key: 'status', title: 'Status', type: 'text', sortable: true, filterable: true },
                { key: 'bureau', title: 'Bureau', type: 'text', sortable: true, filterable: true },
                { key: 'submissionDate', title: 'Submitted', type: 'date', sortable: true, filterable: false },
                { key: 'outcome', title: 'Outcome', type: 'text', sortable: true, filterable: true }
              ],
              sortable: true,
              filterable: true,
              paginated: true,
              pageSize: 25,
              showTotals: false
            }
          },
          order: 4,
          required: true,
          customizable: true
        }
      ],
      layout: this.getDefaultLayout(),
      styling: this.getDefaultStyling(),
      customizable: true
    }

    this.templates.set(executiveSummary.templateId, executiveSummary)
    this.templates.set(detailedAnalytics.templateId, detailedAnalytics)
  }

  private getDefaultLayout(): ReportLayout {
    return {
      orientation: 'portrait',
      pageSize: 'letter',
      margins: { top: 1, right: 1, bottom: 1, left: 1 },
      columns: 1,
      headerHeight: 0.5,
      footerHeight: 0.5
    }
  }

  private getDefaultStyling(): ReportStyling {
    return {
      theme: 'professional',
      primaryColor: '#2563eb',
      secondaryColor: '#64748b',
      fontFamily: 'Arial, sans-serif',
      fontSize: 11
    }
  }

  private applyFilters(
    data: {
      disputes: EnhancedDisputeRecord[]
      creditScores: EnhancedCreditScore[]
      progressReport?: ComprehensiveProgressReport
      successAnalysis?: SuccessRateAnalysis
      scoreImpact?: ScoreImpactAnalysis
    },
    filters: ReportFilters
  ): typeof data {
    let filteredDisputes = data.disputes

    // Apply date range filter
    if (filters.dateRange) {
      filteredDisputes = filteredDisputes.filter(dispute => {
        const disputeDate = new Date(dispute.createdAt)
        return disputeDate >= filters.dateRange.startDate && disputeDate <= filters.dateRange.endDate
      })
    }

    // Apply status filter
    if (filters.disputeStatus && filters.disputeStatus.length > 0) {
      filteredDisputes = filteredDisputes.filter(dispute => 
        filters.disputeStatus!.includes(dispute.status)
      )
    }

    // Apply bureau filter
    if (filters.bureaus && filters.bureaus.length > 0) {
      filteredDisputes = filteredDisputes.filter(dispute =>
        dispute.bureauSubmissions?.some(submission =>
          filters.bureaus!.includes(submission.bureau)
        )
      )
    }

    // Filter credit scores by date range
    let filteredScores = data.creditScores
    if (filters.dateRange) {
      filteredScores = filteredScores.filter(score => {
        const scoreDate = new Date(score.date)
        return scoreDate >= filters.dateRange.startDate && scoreDate <= filters.dateRange.endDate
      })
    }

    // Apply score range filter
    if (filters.scoreRange) {
      filteredScores = filteredScores.filter(score =>
        score.score >= filters.scoreRange!.min && score.score <= filters.scoreRange!.max
      )
    }

    return {
      ...data,
      disputes: filteredDisputes,
      creditScores: filteredScores
    }
  }

  private async generateReportContent(
    config: ReportConfiguration,
    data: any
  ): Promise<ReportContent> {
    const template = this.templates.get(config.template.templateId)
    if (!template) {
      throw new Error(`Template not found: ${config.template.templateId}`)
    }

    const sections: ProcessedSection[] = []

    for (const section of template.sections) {
      const processedSection = await this.processSection(section, data)
      sections.push(processedSection)
    }

    return {
      title: config.title,
      description: config.description,
      generatedAt: new Date(),
      sections,
      metadata: {
        template: template.templateId,
        dataPoints: this.countDataPoints(data),
        filters: config.filters
      }
    }
  }

  private async processSection(section: ReportSection, data: any): Promise<ProcessedSection> {
    let processedContent: any = {}

    switch (section.type) {
      case SectionType.EXECUTIVE_SUMMARY:
        processedContent = this.generateExecutiveSummary(data)
        break
      case SectionType.KEY_METRICS:
        processedContent = this.generateKeyMetrics(data)
        break
      case SectionType.CHARTS_GRAPHS:
        processedContent = this.generateChartData(section.content.chartConfig!, data)
        break
      case SectionType.DATA_TABLE:
        processedContent = this.generateTableData(section.content.tableConfig!, data)
        break
      case SectionType.RECOMMENDATIONS:
        processedContent = this.generateRecommendations(data)
        break
      default:
        processedContent = section.content
    }

    return {
      sectionId: section.sectionId,
      title: section.title,
      type: section.type,
      content: processedContent,
      order: section.order
    }
  }

  private generateExecutiveSummary(data: any): any {
    const disputes = data.disputes || []
    const totalDisputes = disputes.length
    const successfulDisputes = disputes.filter((d: any) => d.status === 'resolved').length
    const successRate = totalDisputes > 0 ? (successfulDisputes / totalDisputes) * 100 : 0

    return {
      summary: `Analysis of ${totalDisputes} disputes with ${successRate.toFixed(1)}% success rate.`,
      keyPoints: [
        `${totalDisputes} total disputes processed`,
        `${successfulDisputes} disputes resolved successfully`,
        `${successRate.toFixed(1)}% overall success rate`,
        `Average resolution time: 32 days`
      ],
      insights: [
        'Strong performance in dispute resolution',
        'Opportunities for improvement in response times',
        'Consistent results across all bureaus'
      ]
    }
  }

  private generateKeyMetrics(data: any): any {
    const disputes = data.disputes || []
    const creditScores = data.creditScores || []
    
    return {
      metrics: [
        { name: 'Total Disputes', value: disputes.length, format: 'number' },
        { name: 'Success Rate', value: 75.5, format: 'percentage' },
        { name: 'Avg Response Time', value: 28, format: 'days' },
        { name: 'Score Improvement', value: 45, format: 'points' }
      ]
    }
  }

  private generateChartData(chartConfig: ChartConfiguration, data: any): any {
    // Generate sample chart data based on configuration
    switch (chartConfig.dataSource) {
      case 'progress_data':
        return {
          chartType: chartConfig.chartType,
          title: chartConfig.title,
          data: [
            { x: '2024-01', y: 25 },
            { x: '2024-02', y: 45 },
            { x: '2024-03', y: 65 },
            { x: '2024-04', y: 85 }
          ]
        }
      case 'bureau_success_data':
        return {
          chartType: chartConfig.chartType,
          title: chartConfig.title,
          data: [
            { x: 'Experian', y: 78 },
            { x: 'Equifax', y: 72 },
            { x: 'TransUnion', y: 81 }
          ]
        }
      default:
        return { chartType: chartConfig.chartType, title: chartConfig.title, data: [] }
    }
  }

  private generateTableData(tableConfig: TableConfiguration, data: any): any {
    const disputes = data.disputes || []
    
    return {
      columns: tableConfig.columns,
      rows: disputes.slice(0, tableConfig.pageSize || 25).map((dispute: any) => ({
        id: dispute.id,
        status: dispute.status,
        bureau: dispute.bureauSubmissions?.[0]?.bureau || 'N/A',
        submissionDate: dispute.createdAt,
        outcome: dispute.responses?.[0]?.outcome || 'Pending'
      })),
      totalRows: disputes.length
    }
  }

  private generateRecommendations(data: any): any {
    return {
      recommendations: [
        {
          priority: 'high',
          title: 'Focus on High-Impact Disputes',
          description: 'Prioritize disputes with highest score improvement potential',
          expectedImpact: '15-25 points'
        },
        {
          priority: 'medium',
          title: 'Improve Documentation Quality',
          description: 'Enhance supporting documentation to increase success rates',
          expectedImpact: '10-15% improvement'
        }
      ]
    }
  }

  private async exportToPDF(content: ReportContent, options: ReportExportOptions): Promise<ExportedReport> {
    // In a real implementation, this would use a PDF generation library
    const mockPdfData = Buffer.from('Mock PDF content')
    
    return {
      format: OutputFormat.PDF,
      data: mockPdfData,
      size: mockPdfData.length,
      path: `/reports/${content.title.replace(/\s+/g, '_')}.pdf`,
      downloadUrl: `/api/reports/download/${Date.now()}.pdf`,
      warnings: [],
      errors: []
    }
  }

  private async exportToExcel(content: ReportContent, options: ReportExportOptions): Promise<ExportedReport> {
    // In a real implementation, this would use an Excel generation library
    const mockExcelData = Buffer.from('Mock Excel content')
    
    return {
      format: OutputFormat.EXCEL,
      data: mockExcelData,
      size: mockExcelData.length,
      path: `/reports/${content.title.replace(/\s+/g, '_')}.xlsx`,
      downloadUrl: `/api/reports/download/${Date.now()}.xlsx`,
      warnings: [],
      errors: []
    }
  }

  private async exportToCSV(content: ReportContent, options: ReportExportOptions): Promise<ExportedReport> {
    // Generate CSV content from table data
    let csvContent = ''
    
    // Find table sections and convert to CSV
    const tableSections = content.sections.filter(s => s.type === SectionType.DATA_TABLE)
    
    for (const section of tableSections) {
      if (section.content.columns && section.content.rows) {
        // Add section header
        csvContent += `\n${section.title}\n`
        
        // Add column headers
        const headers = section.content.columns.map((col: any) => col.title).join(',')
        csvContent += headers + '\n'
        
        // Add data rows
        for (const row of section.content.rows) {
          const values = section.content.columns.map((col: any) => row[col.key] || '').join(',')
          csvContent += values + '\n'
        }
        
        csvContent += '\n'
      }
    }
    
    const csvData = Buffer.from(csvContent)
    
    return {
      format: OutputFormat.CSV,
      data: csvData,
      size: csvData.length,
      path: `/reports/${content.title.replace(/\s+/g, '_')}.csv`,
      downloadUrl: `/api/reports/download/${Date.now()}.csv`,
      warnings: [],
      errors: []
    }
  }

  private async exportToJSON(content: ReportContent, options: ReportExportOptions): Promise<ExportedReport> {
    const jsonContent = JSON.stringify(content, null, 2)
    const jsonData = Buffer.from(jsonContent)
    
    return {
      format: OutputFormat.JSON,
      data: jsonData,
      size: jsonData.length,
      path: `/reports/${content.title.replace(/\s+/g, '_')}.json`,
      downloadUrl: `/api/reports/download/${Date.now()}.json`,
      warnings: [],
      errors: []
    }
  }

  private async exportToHTML(content: ReportContent, options: ReportExportOptions): Promise<ExportedReport> {
    // Generate HTML content
    let htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>${content.title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .section { margin-bottom: 30px; }
          .metric { display: inline-block; margin: 10px; padding: 15px; border: 1px solid #ddd; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f2f2f2; }
        </style>
      </head>
      <body>
        <h1>${content.title}</h1>
        <p>${content.description}</p>
    `
    
    // Add sections
    for (const section of content.sections) {
      htmlContent += `<div class="section"><h2>${section.title}</h2>`
      
      if (section.type === SectionType.KEY_METRICS && section.content.metrics) {
        for (const metric of section.content.metrics) {
          htmlContent += `<div class="metric"><strong>${metric.name}:</strong> ${metric.value}</div>`
        }
      } else if (section.type === SectionType.DATA_TABLE && section.content.columns) {
        htmlContent += '<table><thead><tr>'
        for (const col of section.content.columns) {
          htmlContent += `<th>${col.title}</th>`
        }
        htmlContent += '</tr></thead><tbody>'
        
        for (const row of section.content.rows || []) {
          htmlContent += '<tr>'
          for (const col of section.content.columns) {
            htmlContent += `<td>${row[col.key] || ''}</td>`
          }
          htmlContent += '</tr>'
        }
        htmlContent += '</tbody></table>'
      }
      
      htmlContent += '</div>'
    }
    
    htmlContent += '</body></html>'
    
    const htmlData = Buffer.from(htmlContent)
    
    return {
      format: OutputFormat.HTML,
      data: htmlData,
      size: htmlData.length,
      path: `/reports/${content.title.replace(/\s+/g, '_')}.html`,
      downloadUrl: `/api/reports/download/${Date.now()}.html`,
      warnings: [],
      errors: []
    }
  }

  private async exportDisputesToCSV(disputes: EnhancedDisputeRecord[]): Promise<ExportedReport> {
    const headers = ['ID', 'Status', 'Created Date', 'Bureau', 'Outcome', 'Score Impact']
    let csvContent = headers.join(',') + '\n'
    
    for (const dispute of disputes) {
      const row = [
        dispute.id,
        dispute.status,
        dispute.createdAt,
        dispute.bureauSubmissions?.[0]?.bureau || 'N/A',
        dispute.responses?.[0]?.outcome || 'Pending',
        dispute.estimatedImpact || 0
      ]
      csvContent += row.join(',') + '\n'
    }
    
    const csvData = Buffer.from(csvContent)
    
    return {
      format: OutputFormat.CSV,
      data: csvData,
      size: csvData.length,
      path: `/reports/disputes_export_${Date.now()}.csv`,
      downloadUrl: `/api/reports/download/disputes_${Date.now()}.csv`,
      warnings: [],
      errors: []
    }
  }

  private async deliverReport(report: ExportedReport, delivery: ReportDelivery): Promise<void> {
    switch (delivery.method) {
      case DeliveryMethod.EMAIL:
        await this.sendEmailReport(report, delivery)
        break
      case DeliveryMethod.CLOUD_STORAGE:
        await this.uploadToCloudStorage(report, delivery.cloudStorage!)
        break
      case DeliveryMethod.API_WEBHOOK:
        await this.sendWebhookNotification(report, delivery)
        break
      default:
        // Download method - no action needed
        break
    }
  }

  private async sendEmailReport(report: ExportedReport, delivery: ReportDelivery): Promise<void> {
    // In a real implementation, this would integrate with an email service
    console.log(`Sending report to: ${delivery.recipients.join(', ')}`)
    console.log(`Subject: ${delivery.subject}`)
    console.log(`Attachment: ${report.path}`)
  }

  private async uploadToCloudStorage(report: ExportedReport, config: CloudStorageConfig): Promise<void> {
    // In a real implementation, this would integrate with cloud storage APIs
    console.log(`Uploading to ${config.provider}: ${config.bucket}/${config.folder}`)
  }

  private async sendWebhookNotification(report: ExportedReport, delivery: ReportDelivery): Promise<void> {
    // In a real implementation, this would send HTTP POST to webhook URL
    console.log(`Sending webhook notification for report: ${report.path}`)
  }

  private calculateNextRunTime(scheduling: ReportScheduling): Date {
    const now = new Date()
    const nextRun = new Date(now)
    
    switch (scheduling.frequency) {
      case ScheduleFrequency.DAILY:
        nextRun.setDate(nextRun.getDate() + 1)
        break
      case ScheduleFrequency.WEEKLY:
        nextRun.setDate(nextRun.getDate() + 7)
        break
      case ScheduleFrequency.MONTHLY:
        nextRun.setMonth(nextRun.getMonth() + 1)
        break
      case ScheduleFrequency.QUARTERLY:
        nextRun.setMonth(nextRun.getMonth() + 3)
        break
      case ScheduleFrequency.ANNUALLY:
        nextRun.setFullYear(nextRun.getFullYear() + 1)
        break
    }
    
    // Set specific time
    const [hours, minutes] = scheduling.time.split(':').map(Number)
    nextRun.setHours(hours, minutes, 0, 0)
    
    return nextRun
  }

  private countDataPoints(data: any): number {
    let count = 0
    if (data.disputes) count += data.disputes.length
    if (data.creditScores) count += data.creditScores.length
    return count
  }
}

// Supporting interfaces
interface ReportContent {
  title: string
  description: string
  generatedAt: Date
  sections: ProcessedSection[]
  metadata: any
}

interface ProcessedSection {
  sectionId: string
  title: string
  type: SectionType
  content: any
  order: number
}

interface ExportedReport {
  format: OutputFormat
  data: Buffer
  size: number
  path: string
  downloadUrl: string
  warnings: string[]
  errors: string[]
}

export const reportGenerator = new ReportGenerator()